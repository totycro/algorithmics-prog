\documentclass[,%fontsize=11pt,%
			paper=a4,% 
			%DIV12, % mehr text pro seite als defaultyyp
			DIV12,
			%DIV=calc,%
			%twoside=false,%
			liststotoc,
			bibtotoc,
			draft=false,% final|draft % draft ist platzsparender (kein code, bilder..)
			%titlepage,
			numbers=noendperiod
			]{scrartcl}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}


%\usepackage{vaucanson-g}
%\usepackage{amssymb}
%\usepackage{latexsym}

% for color-highlighted code
%\usepackage{color} % for grey comments
%\usepackage{alltt}

%\usepackage[doublespacing]{setspace}
\usepackage[onehalfspacing]{setspace}
%\usepackage[singlespacing]{setspace}
\usepackage{tabularx}
%\usepackage{hyperref}
\usepackage{comment}
\usepackage{color}
\usepackage{url}      % for urls
\usepackage{multicol}
\usepackage{float}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}

\usepackage{soul}

\newcommand{\mst}{\textbf{MST}}
\newcommand{\kmst}{\textit{k}-\mst}

\definecolor{grey2}{gray}{.90}
\sethlcolor{grey2}
\newcommand{\ilc}[1]{\hl{\texttt{#1}}} % ilc = inline code

\title{Report on the implementation of the \kmst\ problem as integer linear program}
\author{Bernhard Mallinger \\ 0707663 \and Christof Schmidt \\ deine matr nr?}

\begin{document}

\maketitle

\section{Problem description}

The \kmst\ problem is a variation of the Minimum Spanning Tree (\mst) problem for undirected graphs $G = (V, E, w)$, including a weight function $w(e) : E \rightarrow \mathbb{R}^+_0$.
The goal of both problems is to find a tree of minimum cost, but instead of requiring it to span the whole graph as in the classical \mst, for the \kmst, the tree has to span a given number of $k$ arbitrary nodes.
This restriction turns the formerly tractable problem into an $NP$-complete one.

\section{General formulation}

This section describes all variables and constraints, that the formulations for connectivity share. It deals mostly with representing the graph as well as ensuring acyclicity.

In order to represent the graph, we chose to use a Boolean array \ilc{edges} containing a directed variants of the originally undirected edges.
This will simplify the management of flow later on.
\ilc{edges} contains $2|E|$ elements, where the first half represents the edges in one direction and the other half the opposite ones.
Since trees are acyclic, we can require that only one of the two directed edges that are derived from an undirected edge in the original graph are chosen:
\begin{equation}
 \ilc{edges}[i] + \ilc{edges}[i + |E|] \leq 1\quad\forall~0\leq i \leq |E|
\end{equation}

Furthermore, to avoid circles in the set of solutions, we require that each vertex has at most one incoming edge (\eqref{eq:oneIncoming}) with a special treatment of the artificial root node, which must not have any incoming edge at all (\eqref{eq:root0}) but exactly one outgoing node (\eqref{eq:root1}). 
As the connectivity constraints take effect later, this will ensure that once a node is reached from the root node, there cannot be a path back it (which would form a circle), since then the number of incoming edges would exceed 1.
In order to add the constraints only for the relevant and existing edges, we implemented two auxiliary functions: \ilc{incomingEdges}, which returns for a node \ilc{j} the set of indices in the \ilc{edges}-array which correspond to edges incoming to \ilc{j}, and \ilc{outgoingEdges}, which works analoguously for outgoing edges.

\begin{equation}\label{eq:oneIncoming}
	\sum_{\mathclap{i\,\in\,\ilc{incomingEdges(j)}}} \ilc{edges}[i] = 1 \quad \forall j \in V
\end{equation}
\begin{equation}\label{eq:root0}
	\sum_{\mathclap{i\,\in\,\ilc{incomingEdges(0)}}} \ilc{edges}[i] = 0
\end{equation}
\begin{equation}\label{eq:root1}
	\sum_{\mathclap{i\,\in\,\ilc{outgoingEdges(0)}}} \ilc{edges}[i] = 1 
\end{equation}

Finally, it is still necessary to state the size of the tree to be calculated.
The problem statement requires the tree to have exactly $k$ nodes, which for trees means that there are $k-1$ edges.
Since this formulation also includes an artificial root node, that is not part of the actual problem, we need to allow a further edge, resulting in $k-1+1=k$ edges in total.
\begin{equation}
	\sum_{i=0}^{2|E|} \ilc{edges}[i] = k
\end{equation}

\section{Connectivity formulations}

The central task of this exercise is to ensure the connectivity of the tree, which can be achieved with any of the following formulations.
The sections are split up into the essential core formulations and strengthening constraints, which are not necessary for correctness but lead to a tighter formulation.

\subsection{Single Commodity Flow Formulation}

The idea of this formulation is to produce flow at the root node, of which every vertex of the solution consumes one unit.
This consumption however can only take place if the flow is delivered to the node on a path that consists of solution edges.
If such a path from the root node to every solution node exists, it is ensured that these vertices are connected.

The concrete modelling is based upon an array of flow values for each edge named \ilc{flow\_scf}.
The variables of this array are constrained to take nonnegative values up to $k$, where the respective value in \ilc{edges} serves as activation flag: A flow greater than 0 is only allowed in case the edge is taken:
\begin{equation}\label{eq:scf1}
	0 \leq \ilc{flow\_scf}[i] \leq k * \ilc{edges}[i] \quad 0 \leq i \leq 2|E|
\end{equation}

The artificial root node $0$ sends out $k$ units of flow:\nolinebreak
\begin{equation}
	\sum_{\mathclap{i\,\in\,\ilc{outgoingEdges(0)}}} \ilc{flow\_scf}[i] = k
\end{equation}

Flow must be conserved, every vertex of the solution sends out as much as it receives minus the one it consumes. In valid solutions, this constraint is only fulfilled by vertices, that are part of the solution. Those differ from the others by having exactly one incoming edge, which is leveraged as activation flag in this formulation:

\begin{equation}
	\sum_{\mathclap{i\,\in\,\ilc{incomingEdges(j)}}} \ilc{flow\_scf}[i] \quad - \quad
	\sum_{\mathclap{i\,\in\,\ilc{outgoingEdges(j)}}} \ilc{flow\_scf}[i] \quad = \quad 
	\sum_{\mathclap{i\,\in\,\ilc{incomingEdges(j)}}} \ilc{edges\_scf}[i] 
	\quad \forall j\,\in\,V
\end{equation}


\subsubsection{Strengthening constraints}

In \eqref{eq:scf1}, the maximum value for the flow is limited by $k$. However since it's a priori deducible that the first edge can only belong to the set of edges leaving the artificial root node, we can tighten the maximum to $k-1$ for all other nodes, as the source of this edge can at most send out this many units of flow.
\begin{equation}\tag{\ref{eq:scf1}$^\prime$}
	0 \leq \ilc{flow\_scf}[i] \leq k * \ilc{edges}[i] \quad \forall i \in \ilc{outgoingEdges(0)} 
\end{equation}
\begin{equation}\tag{\ref{eq:scf1}$^{\prime\prime}$}
	0 \leq \ilc{flow\_scf}[i] \leq (k-1) * \ilc{edges}[i] \quad \forall i \not\in \ilc{outgoingEdges(0)}
\end{equation}

As further optimisation, we tried to restrict the flow variables to integer values, since in valid solutions, they have to be integer. This turned out to have negative effects on the runtime.


\begin{comment}
	- flow on each edge
	- 0 <= flow\_i <= k/k-1 * edge
	- root note emits
	- every node eats/flow conservation
\end{comment}

\subsection{Multi Commodity Flow Formulation}
\subsection{Sequential Formulation}

\section{Results}
obj value, running times, number of b\&b nodes

\section{Interpretation of results}

\end{document}
